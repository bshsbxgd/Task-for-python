#ПУ11-Шэнь Жуйцзи-Задание 1
from dataclasses import dataclass
from typing import Union, Callable
from numbers import Number
import re
import math


#Задание 1.1
@dataclass
class Dual:
    value: float  #Фактическое число
    d: float  #мнимое число

    def __add__(self, other: Union["Dual", Number]) -> "Dual": #сложение
         match other:
            case Dual(o_value, o_d):
                return Dual(self.value + o_value, self.d + o_d)
            case Number():
                return Dual(float(other) + self.value, self.d)

    def __mul__(self, other: Union["Dual", Number]) -> "Dual": #Умножение
         match other:
            case Dual(o_value, o_d):
                return Dual(self.value * o_value, self.value * o_d + self.d * o_value)
            case Number():
                return Dual(float(other) * self.value, float(other) * self.d)
            
    def __sub__(self, other: Union["Dual", Number]) -> "Dual":  #Уменьшение
         match other:
            case Dual(o_value, o_d):
                return Dual(self.value - o_value, self.d - o_d)
            case Number():
                return Dual(self.value - float(other), self.d)
            
    def __truediv__(self, other: Union["Dual", Number]) -> "Dual": #деление
         match other:
            case Dual(o_value, o_d):
                return Dual(self.value / o_value, (self.d * o_value - self.value * o_d) / (o_value * o_value))
            case Number():
                return Dual(self.value / float(other), self.d / float(other))

    def __pow__(self, other: Union["Dual", Number]) -> "Dual":  #Степень
         match other:
            case Dual(e_value, e_d):
                return Dual(self.value ** e_value, (self.d * e_value * self.value ** (e_value - 1)) + (e_d * new_value))
            case Number():
                return Dual( self.value ** float(other), self.d * float(other) * self.value ** (float(other) - 1))

    __rmul__ = __mul__
    __radd__ = __add__
    __rsub__ = __sub__
    __rtruediv__ = __truediv__

def diff(func: Callable[[float], float]) -> Callable[[float], float]:
    return lambda x: func(Dual(x, 1.0)).d

#Функция, которую будем дифференцировать

def f(x: float) -> float:
    return 5 * x * x + 2 / x + 2*x-x

f_diff = diff(f)

# значение производной в точке x = 2
print('-----------------------------------------------------------','\nЗадание 1.1')
for i in range(1,10):
    print('Вывод[f='+str(i)+']:    '+str(f_diff(i)))
print('  ')






#Задание 1.2

# Реализация пользовательской функции exp
def get_exp(x):
    result = 1
    taylor = 1
    for n in range(1, 100):  # Рассчитать разложение ряда Тейлора в первых 100 элементах
        z=1
        for i in range(1,n+1):
            z*=i
        taylor = x**n / z
        result += taylor
    return result

#Выполняется пользовательская функция cos,где для вычисления cos (x) используется ряд Тейлора первых 50 членов.

def get_cos(x):
    result = 0
    for n in range(0,100,2):
        z=1
        for i in range(1,n+1):
            z*=i
        num = 1/z
        taylor = (-1) ** (n/2)*num*x**n
        result += taylor
    return result

# Выполните пользовательскую функцию sin, где используется ряд Тейлора первых 50 членов для вычисления sin (x).
def get_sin(x):
    result = 0
    for n in range(1,100,2):
        z=1
        for i in range(1,n+1):
            z*=i
        num = 1/z
        taylor = (-1) ** ((n-1)/2)*num*x**n
        result += taylor
    return result


# Реализация пользовательской функции log (ниже e)
def get_log(x):
    result = 0
    for n in range(1, 100,2):
        result += 2*1/n*((x-1)/(x+1))**n
    return result

print('-----------------------------------------------------------','\nЗадание 1.2')

for i in range(1,10):
    print('Вывод[exp('+str(i)+')='+str(math.exp(i))+'='+']:    '+str(get_exp(i)))
print('  ')
for i in range(1,10):
    print('Вывод[cos('+str(i)+')='+str(math.cos(i))+'='+']:    '+str(get_cos(i)))
print('  ')
for i in range(1,10):
    print('Вывод[sin('+str(i)+')='+str(math.sin(i))+'='+']:    '+str(get_sin(i)))
print('  ')
for i in range(1,10):
    print('Вывод[log('+str(i)+')='+str(math.log(i))+'='+']:    '+str(get_log(i)))
    

    
    
    
    
#Задание 1.3
print('  ')
print('-----------------------------------------------------------','\nЗадание 1.3')


#Первый способ достижения числового дифференциала
import numpy as np
from scipy.misc import derivative
def f(x): 
    return x**3+6-x/3
print('    ','\n------Первый метод численного дифференцирования:   ')
for x in range(1, 10):
    print('Вывод (x='+str(x)+'):    '+str(derivative(f, x, dx=1e-6)))
    
#Второй способ достижения числовой дифференциации
import numpy as np

def diff1_a(f,x,h):#Форвардная разница
    return (f(x+h)-f(x))/h

def diff1_b(f,x,h):#Обратная разница
    return (f(x)-f(x-h))/h

def diff1_c(f,x,h):#Межосевой дифференциал
    return (f(x+h)-f(x-h))/(2*h)

print('    ','\n------Второй метод численного дифференцирования:    ')
f = lambda x: get_exp(x)+get_log(get_cos(x)-2*get_sin(x))
h = 0.1
for i in range(10,13):
    val1 = diff1_a(f,i,h)
    val2 = diff1_b(f,i,h)
    val3 = diff1_c(f,i,h)
    print('    ','\nКогда i=',str(i),':')
    print('Форвардная разница(i=',str(i),'):     ',val1)
    print('Обратная разница(i=',str(i),'):     ',val2)
    print('Межосевой дифференциал(i=',str(i),'):     ',val3)


    


    
    
    
    
#Задание 1.4
print('  ')
print('-----------------------------------------------------------','\nЗадание 1.4','\nСлева: результат символьного дифференцирования, справа: результат численного дифференцирования.')


import numpy as np
from scipy.misc import derivative

#Символический дифференциальный и численный дифференциальный сравнительный тест 1
def f(x):
    return  x ** -3 + 1+5/4
result_list1 = []
f1 = lambda x:  x ** -3 + 1+5/4
result_list2 = []
zz=[]
for x in range(1,11):
    result_list1.append(derivative(f, x, dx=1e-6))#Символическое дифференцирование
    result_list2.append(diff1_c(f1,x,h))
    zz.append(x)
z = zip(result_list1,result_list2) 
print('\n')
print('Выражение 1: f(x)=x ** -3 + 1+5/4')
for i,q in zip(z,zz):
    print('    ','Когда x=',str(q),':','\n',i)
    
#Символический дифференциальный и численный дифференциальный сравнительный тест 2
def f(x):
    return  get_log(x)+get_sin(x)+get_cos(x)
result_list3 = []
f1 = lambda x:  get_log(x)+get_sin(x)+get_cos(x)
result_list4 = []
zz=[]
for x in range(1,11):
    result_list3.append(derivative(f, x, dx=1e-6))#Символическое дифференцирование
    result_list4.append(diff1_c(f1,x,h))
    zz.append(x)
z = zip(result_list3,result_list4) 
print('\n')
print('Выражение 2: f(x)=get_log(x)+get_sin(x)+get_cos(x)')
for i,q in zip(z,zz):
    print('    ','Когда x=',str(q),':','\n',i)
    
#Символический дифференциальный и численный дифференциальный сравнительный тест 3
def f(x):
    return  2*x**2+get_exp(x)*get_cos(x)+get_log(x/6)
result_list5 = []
f1 = lambda x:  2*x**2+get_exp(x)*get_cos(x)+get_log(x/6)
result_list6 = []
zz=[]
for x in range(1,11):
    result_list5.append(derivative(f, x, dx=1e-6))#Символическое дифференцирование
    result_list6.append(diff1_c(f1,x,h))
    zz.append(x)
z = zip(result_list5,result_list6) 
print('\n')
print('Выражение 3: f(x)=2*x**2+get_exp(x)*get_cos(x)+get_log(x/6)')
for i,q in zip(z,zz):
    print('    ','Когда x=',str(q),':','\n',i)

    
    
    
    
#Задание 1.5
'''Реализуйте поддержку функций нескольких аргументов. Например
def f(x: float, y: float, z: float) -> float:
    return x * y + z - 5 * y  
f_diff = diff(f)
f_diff(10, 10, 10) # = [10, 5, 1]'''
print('  ')
print('-----------------------------------------------------------','\nЗадание 1.5')
from sympy import symbols, diff

def derivative(*args, **kwargs):
    x, y, z = symbols('x y z')
    fnl = x * y + z - 5 * y
    result = {}
    for arg in args:
        result[arg] = diff(fnl, arg).subs(kwargs)
    return result

print(derivative('x', 'y', 'z', x=10, y=10, z=10))
